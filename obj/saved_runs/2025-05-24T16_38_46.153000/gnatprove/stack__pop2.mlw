module Standard__natural
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type natural = <range 0 2147483647>
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (2147483647 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = natural,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type natural__ref = { mutable natural__content : natural }
  
  function natural__ref_natural__content__projection (a: natural__ref) : natural =
    a.natural__content
  
  meta "model_projection" function natural__ref_natural__content__projection
  
  meta "inline:no" function natural__ref_natural__content__projection
  
  val natural__havoc (x: natural__ref) : unit
    writes { x }
end

module Standard__natural__rep
  use Standard__natural as Standard__natural
  use _gnatprove_standard.Main
  use int.Int
  
  function to_rep (x: Standard__natural.natural) : int =
    Standard__natural.natural'int x
  
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Standard__natural.natural,
    predicate in_range = Standard__natural.in_range,
    function to_rep = to_rep
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Stack__int32
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type int32 = <range -2147483648 2147483647>
  
  val function first : int
    ensures { result = ((- 2147483648) : int) }
  
  val function last : int
    ensures { result = (2147483647 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = int32,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type int32__ref = { mutable int32__content : int32 }
  
  function int32__ref_int32__content__projection (a: int32__ref) : int32 =
    a.int32__content
  
  meta "model_projection" function int32__ref_int32__content__projection
  
  meta "inline:no" function int32__ref_int32__content__projection
  
  val int32__havoc (x: int32__ref) : unit
    writes { x }
end

module Stack__int32__rep
  use Stack__int32 as Stack__int32
  use _gnatprove_standard.Main
  use int.Int
  
  function to_rep (x: Stack__int32.int32) : int = Stack__int32.int32'int x
  
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Stack__int32.int32,
    predicate in_range = Stack__int32.in_range,
    function to_rep = to_rep
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Array__Int__Stack__int32
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Stack__int32 as Stack__int32
  use Stack__int32__rep as Stack__int32__rep
  
  function index_I1_one : int = 1 : int
  
  type component_type = Stack__int32.int32
  
  clone export _gnatprove_standard.Array__1 with
    axiom .,
    type I1.t = int,
    predicate I1.le = Int.( <= ),
    predicate I1.lt = Int.( < ),
    predicate I1.gt = Int.( > ),
    function I1.add = Int.( + ),
    function I1.sub = Int.( - ),
    function I1.one = index_I1_one,
    type component_type = component_type
  
  function bool_eq (a: map) (a__first: int) (a__last: int) (b: map) (b__first: int) (b__last: int) : bool =
    ((if (a__first <= a__last) then
        ((b__first <= b__last) /\
           ((a__last - a__first) = (b__last - b__first)))
      else (b__first > b__last)) /\
       (forall temp___idx_163 : int.
          if ((a__first <= temp___idx_163) /\ (temp___idx_163 <= a__last)) then
            ((Stack__int32__rep.to_rep ((get a) temp___idx_163))
               = (Stack__int32__rep.to_rep
                    ((get b) ((b__first - a__first) + temp___idx_163))))
          else true))
  
  val bool_eq (a: map) (a__first: int) (a__last: int) (b: map) (b__first: int) (b__last: int) : 
    bool
    ensures { result
      =
      ((((((bool_eq (a : map)) (a__first : int)) (a__last : int)) (b : map))
          (b__first : int))
         (b__last : int)) }
  
  axiom bool_eq_rev:
    forall a : map, b : map.
      forall a__first : int, a__last : int, b__first : int, b__last : int.
        ((((((((bool_eq b) b__first) b__last) a) a__first) a__last) = True) ->
           ((if (a__first <= a__last) then
               ((b__first <= b__last) /\
                  ((a__last - a__first) = (b__last - b__first)))
             else (b__first > b__last)) /\
              (forall temp___idx_163 : int.
                 if ((a__first <= temp___idx_163) /\
                       (temp___idx_163 <= a__last)) then
                   ((Stack__int32__rep.to_rep ((get a) temp___idx_163))
                      = (Stack__int32__rep.to_rep
                           ((get b) ((b__first - a__first) + temp___idx_163))))
                 else true)))
end

module Stack__stack_array
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Stack__int32 as Stack__int32
  use Array__Int__Stack__int32 as Array__Int__Stack__int32
  
  type component_type = Stack__int32.int32
  
  val function first : int
    ensures { result = (1 : int) }
  
  val function last : int
    ensures { result = (512 : int) }
  
  clone export ada__model.Constr_Array with
    axiom .,
    type map = Array__Int__Stack__int32.map,
    function array_bool_eq = Array__Int__Stack__int32.bool_eq,
    function first = first,
    function last = last,
    type index_rep_type = int
end

module Stack__stack_instance__rep
  use _gnatprove_standard.Main
  use int.Int
  use Standard__natural as Standard__natural
  use Standard__natural__rep as Standard__natural__rep
  use Stack__stack_array as Stack__stack_array
  use Array__Int__Stack__int32 as Array__Int__Stack__int32
  use Array__Int__Stack__int32 as Array__Int__Stack__int32
  use Array__Int__Stack__int32 as Array__Int__Stack__int32
  use Array__Int__Stack__int32 as Array__Int__Stack__int32
  
  type __split_fields = {
                       rec__stack__stack_instance__data :
                         Array__Int__Stack__int32.map;
                       rec__stack__stack_instance__top_index :
                         Standard__natural.natural
                       }
  
  function __split_fields_rec__stack__stack_instance__data__projection (a: __split_fields) : 
    Array__Int__Stack__int32.map =
    a.rec__stack__stack_instance__data
  
  meta "model_projection" function __split_fields_rec__stack__stack_instance__data__projection
  
  meta "inline:no" function __split_fields_rec__stack__stack_instance__data__projection
  
  function __split_fields_rec__stack__stack_instance__top_index__projection (a: __split_fields) : 
    Standard__natural.natural =
    a.rec__stack__stack_instance__top_index
  
  meta "model_projection" function __split_fields_rec__stack__stack_instance__top_index__projection
  
  meta "inline:no" function __split_fields_rec__stack__stack_instance__top_index__projection
  
  type __split_fields__ref = {
                            mutable __split_fields__content : __split_fields
                            }
  
  function __split_fields__ref___split_fields__content__projection (a: __split_fields__ref) : __split_fields =
    __split_fields__content a
  
  meta "model_projection" function __split_fields__ref___split_fields__content__projection
  
  meta "inline:no" function __split_fields__ref___split_fields__content__projection
  
  val __split_fields__havoc (x: __split_fields__ref) : unit
    writes { x }
  
  type __rep = { __split_fields : __split_fields }
  
  function __rep___split_fields__projection (a: __rep) : __split_fields =
    __split_fields a
  
  meta "model_projection" function __rep___split_fields__projection
  
  meta "inline:no" function __rep___split_fields__projection
  
  function to_base (a: __rep) : __rep = a
  
  val to_base (a: __rep) : __rep
    ensures { result = (to_base (a : __rep)) }
  
  function of_base (a: __rep) : __rep = a
  
  val of_base (a: __rep) : __rep
    ensures { result = (of_base (a : __rep)) }
  
  predicate stack__stack_instance__data__pred (a: __rep) = true
  
  val stack__stack_instance__data__pred (a: __rep) : bool
    ensures { result <-> (stack__stack_instance__data__pred (a : __rep)) }
  
  val rec__stack__stack_instance__data_ (a: __rep) : Array__Int__Stack__int32.map
    requires { stack__stack_instance__data__pred a }
    ensures { (result
                 = ((__split_fields a).rec__stack__stack_instance__data)) }
  
  predicate stack__stack_instance__top_index__pred (a: __rep) = true
  
  val stack__stack_instance__top_index__pred (a: __rep) : bool
    ensures { result <-> (stack__stack_instance__top_index__pred (a : __rep)) }
  
  val rec__stack__stack_instance__top_index_ (a: __rep) : Standard__natural.natural
    requires { stack__stack_instance__top_index__pred a }
    ensures { (result
                 = ((__split_fields a).rec__stack__stack_instance__top_index)) }
  
  function bool_eq (a: __rep) (b: __rep) : bool =
    if (((Stack__stack_array.bool_eq
            ((__split_fields a).rec__stack__stack_instance__data))
           ((__split_fields b).rec__stack__stack_instance__data)) /\
          ((Standard__natural__rep.to_rep
              ((__split_fields a).rec__stack__stack_instance__top_index))
             = (Standard__natural__rep.to_rep
                  ((__split_fields b).rec__stack__stack_instance__top_index)))) then
      True
    else False
  
  val bool_eq (a: __rep) (b: __rep) : bool
    ensures { result = ((bool_eq (a : __rep)) (b : __rep)) }
end

module Stack__stack_instance
  use export Stack__stack_instance__rep
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type stack_instance = __rep
  
  val function value__size : int
  
  val function object__size : int
  
  val function alignment : int
  
  axiom value__size_axiom: (value__size >= (0 : int))
  
  axiom object__size_axiom: (object__size >= (0 : int))
  
  axiom alignment_axiom: (alignment >= (0 : int))
  
  val function stack__stack_instance__data__first__bit : int
  
  val function stack__stack_instance__data__last__bit : int
  
  val function stack__stack_instance__data__position : int
  
  axiom stack__stack_instance__data__first__bit_axiom:
    (stack__stack_instance__data__first__bit >= (0 : int))
  
  axiom stack__stack_instance__data__last__bit_axiom:
    (stack__stack_instance__data__last__bit
       > stack__stack_instance__data__first__bit)
  
  axiom stack__stack_instance__data__position_axiom:
    (stack__stack_instance__data__position >= (0 : int))
  
  val function stack__stack_instance__top_index__first__bit : int
  
  val function stack__stack_instance__top_index__last__bit : int
  
  val function stack__stack_instance__top_index__position : int
  
  axiom stack__stack_instance__top_index__first__bit_axiom:
    (stack__stack_instance__top_index__first__bit >= (0 : int))
  
  axiom stack__stack_instance__top_index__last__bit_axiom:
    (stack__stack_instance__top_index__last__bit
       > stack__stack_instance__top_index__first__bit)
  
  axiom stack__stack_instance__top_index__position_axiom:
    (stack__stack_instance__top_index__position >= (0 : int))
  
  val function user_eq (a: stack_instance) (b: stack_instance) : bool
  
  val function dummy : stack_instance
  
  type stack_instance__ref = {
                            mutable stack_instance__content : stack_instance
                            }
  
  function stack_instance__ref_stack_instance__content__projection (a: stack_instance__ref) : stack_instance =
    a.stack_instance__content
  
  meta "model_projection" function stack_instance__ref_stack_instance__content__projection
  
  meta "inline:no" function stack_instance__ref_stack_instance__content__projection
  
  val stack_instance__havoc (x: stack_instance__ref) : unit
    writes { x }
end

module Stack__stack_instance___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Standard__natural as Standard__natural
  use Standard__natural__rep as Standard__natural__rep
  use Stack__stack_instance as Stack__stack_instance
  
  predicate dynamic_invariant (temp___expr_207: Stack__stack_instance.stack_instance) (temp___is_init_203: bool) (temp___skip_constant_204: bool) (temp___do_toplevel_205: bool) (temp___do_typ_inv_206: bool) =
    true
  
  val dynamic_invariant (temp___expr_207: Stack__stack_instance.stack_instance) (temp___is_init_203: bool) (temp___skip_constant_204: bool) (temp___do_toplevel_205: bool) (temp___do_typ_inv_206: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant
                       (temp___expr_207 :
                          Stack__stack_instance.stack_instance))
                      (temp___is_init_203 : bool))
                     (temp___skip_constant_204 : bool))
                    (temp___do_toplevel_205 : bool))
                   (temp___do_typ_inv_206 : bool)) }
  
  predicate default_initial_assumption (temp___expr_209: Stack__stack_instance.stack_instance) (temp___skip_top_level_210: bool) =
    if (Stack__stack_instance.stack__stack_instance__top_index__pred
          temp___expr_209) then
      ((Standard__natural__rep.to_rep
          ((Stack__stack_instance.__split_fields temp___expr_209).Stack__stack_instance.rec__stack__stack_instance__top_index))
         = (0 : int))
    else true
  
  val default_initial_assumption (temp___expr_209: Stack__stack_instance.stack_instance) (temp___skip_top_level_210: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption
                    (temp___expr_209 : Stack__stack_instance.stack_instance))
                   (temp___skip_top_level_210 : bool)) }
end

module Pin__pin
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type pin = <range 0 9999>
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (9999 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = pin,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type pin__ref = { mutable pin__content : pin }
  
  function pin__ref_pin__content__projection (a: pin__ref) : pin =
    a.pin__content
  
  meta "model_projection" function pin__ref_pin__content__projection
  
  meta "inline:no" function pin__ref_pin__content__projection
  
  val pin__havoc (x: pin__ref) : unit
    writes { x }
end

module Pin__pin__rep
  use Pin__pin as Pin__pin
  use _gnatprove_standard.Main
  use int.Int
  
  function to_rep (x: Pin__pin.pin) : int = Pin__pin.pin'int x
  
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Pin__pin.pin,
    predicate in_range = Pin__pin.in_range,
    function to_rep = to_rep
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Locker__locker__rep
  use _gnatprove_standard.Main
  use int.Int
  use _gnatprove_standard.Boolean as Boolean
  use Pin__pin as Pin__pin
  use Pin__pin__rep as Pin__pin__rep
  
  type __split_fields = {
                       rec__locker__locker__number : Pin__pin.pin;
                       rec__locker__locker__locked : bool
                       }
  
  function __split_fields_rec__locker__locker__number__projection (a: __split_fields) : 
    Pin__pin.pin =
    a.rec__locker__locker__number
  
  meta "model_projection" function __split_fields_rec__locker__locker__number__projection
  
  meta "inline:no" function __split_fields_rec__locker__locker__number__projection
  
  function __split_fields_rec__locker__locker__locked__projection (a: __split_fields) : bool =
    a.rec__locker__locker__locked
  
  meta "model_projection" function __split_fields_rec__locker__locker__locked__projection
  
  meta "inline:no" function __split_fields_rec__locker__locker__locked__projection
  
  type __split_fields__ref = {
                            mutable __split_fields__content : __split_fields
                            }
  
  function __split_fields__ref___split_fields__content__2__projection (a: __split_fields__ref) : __split_fields =
    __split_fields__content a
  
  meta "model_projection" function __split_fields__ref___split_fields__content__2__projection
  
  meta "inline:no" function __split_fields__ref___split_fields__content__2__projection
  
  val __split_fields__havoc (x: __split_fields__ref) : unit
    writes { x }
  
  type __rep = { __split_fields : __split_fields }
  
  function __rep___split_fields__2__projection (a: __rep) : __split_fields =
    __split_fields a
  
  meta "model_projection" function __rep___split_fields__2__projection
  
  meta "inline:no" function __rep___split_fields__2__projection
  
  function to_base (a: __rep) : __rep = a
  
  val to_base (a: __rep) : __rep
    ensures { result = (to_base (a : __rep)) }
  
  function of_base (a: __rep) : __rep = a
  
  val of_base (a: __rep) : __rep
    ensures { result = (of_base (a : __rep)) }
  
  predicate locker__locker__number__pred (a: __rep) = true
  
  val locker__locker__number__pred (a: __rep) : bool
    ensures { result <-> (locker__locker__number__pred (a : __rep)) }
  
  val rec__locker__locker__number_ (a: __rep) : Pin__pin.pin
    requires { locker__locker__number__pred a }
    ensures { (result = ((__split_fields a).rec__locker__locker__number)) }
  
  predicate locker__locker__locked__pred (a: __rep) = true
  
  val locker__locker__locked__pred (a: __rep) : bool
    ensures { result <-> (locker__locker__locked__pred (a : __rep)) }
  
  val rec__locker__locker__locked_ (a: __rep) : bool
    requires { locker__locker__locked__pred a }
    ensures { (result = ((__split_fields a).rec__locker__locker__locked)) }
  
  function bool_eq (a: __rep) (b: __rep) : bool =
    if (((Pin__pin__rep.to_rep
            ((__split_fields a).rec__locker__locker__number))
           = (Pin__pin__rep.to_rep
                ((__split_fields b).rec__locker__locker__number))) /\
          ((Boolean.to_int ((__split_fields a).rec__locker__locker__locked))
             = (Boolean.to_int
                  ((__split_fields b).rec__locker__locker__locked)))) then
      True
    else False
  
  val bool_eq (a: __rep) (b: __rep) : bool
    ensures { result = ((bool_eq (a : __rep)) (b : __rep)) }
end

module Locker__locker
  use export Locker__locker__rep
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type locker = __rep
  
  val function value__size : int
  
  val function object__size : int
  
  val function alignment : int
  
  axiom value__size_axiom: (value__size >= (0 : int))
  
  axiom object__size_axiom: (object__size >= (0 : int))
  
  axiom alignment_axiom: (alignment >= (0 : int))
  
  val function locker__locker__number__first__bit : int
  
  val function locker__locker__number__last__bit : int
  
  val function locker__locker__number__position : int
  
  axiom locker__locker__number__first__bit_axiom:
    (locker__locker__number__first__bit >= (0 : int))
  
  axiom locker__locker__number__last__bit_axiom:
    (locker__locker__number__last__bit > locker__locker__number__first__bit)
  
  axiom locker__locker__number__position_axiom:
    (locker__locker__number__position >= (0 : int))
  
  val function locker__locker__locked__first__bit : int
  
  val function locker__locker__locked__last__bit : int
  
  val function locker__locker__locked__position : int
  
  axiom locker__locker__locked__first__bit_axiom:
    (locker__locker__locked__first__bit >= (0 : int))
  
  axiom locker__locker__locked__last__bit_axiom:
    (locker__locker__locked__last__bit > locker__locker__locked__first__bit)
  
  axiom locker__locker__locked__position_axiom:
    (locker__locker__locked__position >= (0 : int))
  
  val function user_eq (a: locker) (b: locker) : bool
  
  val function dummy : locker
  
  type locker__ref = { mutable locker__content : locker }
  
  function locker__ref_locker__content__projection (a: locker__ref) : locker =
    a.locker__content
  
  meta "model_projection" function locker__ref_locker__content__projection
  
  meta "inline:no" function locker__ref_locker__content__projection
  
  val locker__havoc (x: locker__ref) : unit
    writes { x }
end

module Stack__pop2__l
  use _gnatprove_standard.Main
  use int.Int
  use Locker__locker as Locker__locker
  
  val function l : Locker__locker.locker
end

module Stack__pop2__s
  use _gnatprove_standard.Main
  use int.Int
  use Stack__stack_instance as Stack__stack_instance
  
  val s__split_fields : Stack__stack_instance.__split_fields__ref
end

module Stack__pop2__a
  use _gnatprove_standard.Main
  use int.Int
  
  val a : int__ref
end

module Stack__pop2__b
  use _gnatprove_standard.Main
  use int.Int
  
  val b : int__ref
end

module Stack__pop2__success
  use _gnatprove_standard.Main
  use int.Int
  
  val success : bool__ref
end

module Locker__is_locked
  use _gnatprove_standard.Main
  use int.Int
  use Locker__locker as Locker__locker
  
  val function is_locked (l: Locker__locker.locker) : bool
  
  val predicate is_locked__function_guard (temp___result_164: bool) (l: 
    Locker__locker.locker)
end

module Locker__locker___axiom
  use _gnatprove_standard.Main
  use int.Int
  use Locker__locker as Locker__locker
  
  predicate dynamic_invariant (temp___expr_226: Locker__locker.locker) (temp___is_init_222: bool) (temp___skip_constant_223: bool) (temp___do_toplevel_224: bool) (temp___do_typ_inv_225: bool) =
    true
  
  val dynamic_invariant (temp___expr_226: Locker__locker.locker) (temp___is_init_222: bool) (temp___skip_constant_223: bool) (temp___do_toplevel_224: bool) (temp___do_typ_inv_225: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant
                       (temp___expr_226 : Locker__locker.locker))
                      (temp___is_init_222 : bool))
                     (temp___skip_constant_223 : bool))
                    (temp___do_toplevel_224 : bool))
                   (temp___do_typ_inv_225 : bool)) }
  
  predicate default_initial_assumption (temp___expr_227: Locker__locker.locker) (temp___skip_top_level_228: bool) =
    true
  
  val default_initial_assumption (temp___expr_227: Locker__locker.locker) (temp___skip_top_level_228: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption
                    (temp___expr_227 : Locker__locker.locker))
                   (temp___skip_top_level_228 : bool)) }
end

module Locker__is_locked___axiom
  use _gnatprove_standard.Main
  use int.Int
  use Locker__locker as Locker__locker
  use Locker__is_locked as Locker__is_locked
  use Locker__locker___axiom as Locker__locker___axiom
  
  val is_locked (l: Locker__locker.locker) : bool
    requires { true }
    ensures { (((result = (Locker__is_locked.is_locked l)) /\
                  ((Locker__is_locked.is_locked__function_guard result) l)) /\
                 true) }
  
  axiom is_locked__post_axiom:
    forall l : Locker__locker.locker [Locker__is_locked.is_locked l].
      ((((((Locker__locker___axiom.dynamic_invariant l) True) True) True)
          True) ->
         (let result = Locker__is_locked.is_locked l in
          if ((Locker__is_locked.is_locked__function_guard result) l) then
            ((true /\ true) /\ true)
          else true))
end

module Stack__stack_index
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type stack_index = <range 1 512>
  
  val function first : int
    ensures { result = (1 : int) }
  
  val function last : int
    ensures { result = (512 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = stack_index,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type stack_index__ref = { mutable stack_index__content : stack_index }
  
  function stack_index__ref_stack_index__content__projection (a: stack_index__ref) : stack_index =
    a.stack_index__content
  
  meta "model_projection" function stack_index__ref_stack_index__content__projection
  
  meta "inline:no" function stack_index__ref_stack_index__content__projection
  
  val stack_index__havoc (x: stack_index__ref) : unit
    writes { x }
end

module Stack__int32___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Stack__int32 as Stack__int32
  
  predicate dynamic_invariant (temp___expr_190: int) (temp___is_init_186: bool) (temp___skip_constant_187: bool) (temp___do_toplevel_188: bool) (temp___do_typ_inv_189: bool) =
    if ((temp___is_init_186 = True) \/
          (Stack__int32.first <= Stack__int32.last)) then
      (((Stack__int32.dynamic_property Stack__int32.first) Stack__int32.last)
         temp___expr_190)
    else true
  
  val dynamic_invariant (temp___expr_190: int) (temp___is_init_186: bool) (temp___skip_constant_187: bool) (temp___do_toplevel_188: bool) (temp___do_typ_inv_189: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_190 : int))
                      (temp___is_init_186 : bool))
                     (temp___skip_constant_187 : bool))
                    (temp___do_toplevel_188 : bool))
                   (temp___do_typ_inv_189 : bool)) }
  
  predicate default_initial_assumption (temp___expr_191: int) (temp___skip_top_level_192: bool) =
    true
  
  val default_initial_assumption (temp___expr_191: int) (temp___skip_top_level_192: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_191 : int))
                   (temp___skip_top_level_192 : bool)) }
end

module Standard__natural___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Standard__natural as Standard__natural
  
  predicate dynamic_invariant (temp___expr_46: int) (temp___is_init_42: bool) (temp___skip_constant_43: bool) (temp___do_toplevel_44: bool) (temp___do_typ_inv_45: bool) =
    if ((temp___is_init_42 = True) \/
          (Standard__natural.first <= Standard__natural.last)) then
      (((Standard__natural.dynamic_property Standard__natural.first)
          Standard__natural.last)
         temp___expr_46)
    else true
  
  val dynamic_invariant (temp___expr_46: int) (temp___is_init_42: bool) (temp___skip_constant_43: bool) (temp___do_toplevel_44: bool) (temp___do_typ_inv_45: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_46 : int))
                      (temp___is_init_42 : bool))
                     (temp___skip_constant_43 : bool))
                    (temp___do_toplevel_44 : bool))
                   (temp___do_typ_inv_45 : bool)) }
  
  predicate default_initial_assumption (temp___expr_47: int) (temp___skip_top_level_48: bool) =
    true
  
  val default_initial_assumption (temp___expr_47: int) (temp___skip_top_level_48: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_47 : int))
                   (temp___skip_top_level_48 : bool)) }
end

module Stack__stack_index___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Stack__stack_index as Stack__stack_index
  
  predicate dynamic_invariant (temp___expr_176: int) (temp___is_init_172: bool) (temp___skip_constant_173: bool) (temp___do_toplevel_174: bool) (temp___do_typ_inv_175: bool) =
    if ((temp___is_init_172 = True) \/
          (Stack__stack_index.first <= Stack__stack_index.last)) then
      (((Stack__stack_index.dynamic_property Stack__stack_index.first)
          Stack__stack_index.last)
         temp___expr_176)
    else true
  
  val dynamic_invariant (temp___expr_176: int) (temp___is_init_172: bool) (temp___skip_constant_173: bool) (temp___do_toplevel_174: bool) (temp___do_typ_inv_175: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_176 : int))
                      (temp___is_init_172 : bool))
                     (temp___skip_constant_173 : bool))
                    (temp___do_toplevel_174 : bool))
                   (temp___do_typ_inv_175 : bool)) }
  
  predicate default_initial_assumption (temp___expr_177: int) (temp___skip_top_level_178: bool) =
    true
  
  val default_initial_assumption (temp___expr_177: int) (temp___skip_top_level_178: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_177 : int))
                   (temp___skip_top_level_178 : bool)) }
end

module Stack__stack_array___axiom
  use _gnatprove_standard.Main
  use int.Int
  use Array__Int__Stack__int32 as Array__Int__Stack__int32
  use Array__Int__Stack__int32 as Array__Int__Stack__int32
  
  predicate dynamic_invariant (temp___expr_197: Array__Int__Stack__int32.map) (temp___is_init_193: bool) (temp___skip_constant_194: bool) (temp___do_toplevel_195: bool) (temp___do_typ_inv_196: bool) =
    true
  
  val dynamic_invariant (temp___expr_197: Array__Int__Stack__int32.map) (temp___is_init_193: bool) (temp___skip_constant_194: bool) (temp___do_toplevel_195: bool) (temp___do_typ_inv_196: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant
                       (temp___expr_197 : Array__Int__Stack__int32.map))
                      (temp___is_init_193 : bool))
                     (temp___skip_constant_194 : bool))
                    (temp___do_toplevel_195 : bool))
                   (temp___do_typ_inv_196 : bool)) }
  
  predicate default_initial_assumption (temp___expr_199: Array__Int__Stack__int32.map) (temp___skip_top_level_200: bool) =
    true
  
  val default_initial_assumption (temp___expr_199: Array__Int__Stack__int32.map) (temp___skip_top_level_200: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption
                    (temp___expr_199 : Array__Int__Stack__int32.map))
                   (temp___skip_top_level_200 : bool)) }
end

module Stack__pop2__l___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Stack__pop2__s___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Stack__pop2__a___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Stack__pop2__b___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Stack__pop2__success___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Pin__pin___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Pin__pin as Pin__pin
  
  predicate dynamic_invariant (temp___expr_219: int) (temp___is_init_215: bool) (temp___skip_constant_216: bool) (temp___do_toplevel_217: bool) (temp___do_typ_inv_218: bool) =
    if ((temp___is_init_215 = True) \/ (Pin__pin.first <= Pin__pin.last)) then
      (((Pin__pin.dynamic_property Pin__pin.first) Pin__pin.last)
         temp___expr_219)
    else true
  
  val dynamic_invariant (temp___expr_219: int) (temp___is_init_215: bool) (temp___skip_constant_216: bool) (temp___do_toplevel_217: bool) (temp___do_typ_inv_218: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_219 : int))
                      (temp___is_init_215 : bool))
                     (temp___skip_constant_216 : bool))
                    (temp___do_toplevel_217 : bool))
                   (temp___do_typ_inv_218 : bool)) }
  
  predicate default_initial_assumption (temp___expr_220: int) (temp___skip_top_level_221: bool) =
    true
  
  val default_initial_assumption (temp___expr_220: int) (temp___skip_top_level_221: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_220 : int))
                   (temp___skip_top_level_221 : bool)) }
end

module Stack__pop2__subprogram_def
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use _gnatprove_standard.Main as Main
  use _gnatprove_standard.Boolean as Boolean
  use Standard__natural as Standard__natural
  use Standard__natural__rep as Standard__natural__rep
  use Stack__stack_instance as Stack__stack_instance
  use Stack__stack_instance___axiom as Stack__stack_instance___axiom
  use Locker__locker as Locker__locker
  use Stack__pop2__l as Stack__pop2__l
  use Stack__pop2__s as Stack__pop2__s
  use Stack__pop2__a as Stack__pop2__a
  use Stack__pop2__b as Stack__pop2__b
  use Stack__pop2__success as Stack__pop2__success
  use Locker__is_locked___axiom as Locker__is_locked___axiom
  use Stack__stack_index as Stack__stack_index
  use Stack__int32 as Stack__int32
  use Stack__int32___axiom as Stack__int32___axiom
  use Stack__int32__rep as Stack__int32__rep
  use Array__Int__Stack__int32 as Array__Int__Stack__int32
  use Locker__locker___axiom as Locker__locker___axiom
  use Array__Int__Stack__int32 as Array__Int__Stack__int32
  use Array__Int__Stack__int32 as Array__Int__Stack__int32
  use Standard__natural___axiom as Standard__natural___axiom
  use Stack__stack_index___axiom as Stack__stack_index___axiom
  use Stack__int32___axiom as Stack__int32___axiom
  use Stack__stack_array___axiom as Stack__stack_array___axiom
  use Stack__pop2__l___axiom as Stack__pop2__l___axiom
  use Stack__pop2__s___axiom as Stack__pop2__s___axiom
  use Stack__pop2__a___axiom as Stack__pop2__a___axiom
  use Stack__pop2__b___axiom as Stack__pop2__b___axiom
  use Stack__pop2__success___axiom as Stack__pop2__success___axiom
  use Stack__stack_instance___axiom as Stack__stack_instance___axiom
  use Locker__is_locked___axiom as Locker__is_locked___axiom
  use Locker__locker___axiom as Locker__locker___axiom
  use Pin__pin___axiom as Pin__pin___axiom
  
  let def (__void_param : unit)
    requires { [#"stack.ads" 25 0 0] true }
  = [@vc:divergent]
    (([@GNAT-comment:Assume dynamic invariants of inputs of the subprogram stack.ads:25]
      ());
     ([#"stack.ads" 25 0 0]
      assume {
        [#"stack.ads" 25 0 0]
        (((((Locker__locker___axiom.dynamic_invariant Stack__pop2__l.l) True)
             False)
            True)
           True) });
     ([#"stack.ads" 25 0 0]
      assume {
        [#"stack.ads" 25 0 0]
        (((((Stack__stack_instance___axiom.dynamic_invariant
               { Stack__stack_instance.__split_fields =
                   (Stack__stack_instance.__split_fields__content
                       Stack__pop2__s.s__split_fields) })
              True)
             False)
            True)
           True) });
     ([#"stack.ads" 25 0 0]
      assume {
        [#"stack.ads" 25 0 0]
        (((((Stack__int32___axiom.dynamic_invariant
               (Stack__pop2__a.a.int__content))
              False)
             False)
            True)
           True) });
     ([#"stack.ads" 25 0 0]
      assume {
        [#"stack.ads" 25 0 0]
        (((((Stack__int32___axiom.dynamic_invariant
               (Stack__pop2__b.b.int__content))
              False)
             False)
            True)
           True) });
     ([@GNAT-comment:Assume moved pointers in outputs of the subprogram stack.ads:25]
      ());
     ([@GNAT-comment:Check for RTE in the Pre of the subprogram stack.ads:25]
      ());
     ([#"stack.ads" 25 0 0] ());
     ([@GNAT-comment:Assume Pre of the subprogram stack.ads:25] ());
     ([#"stack.ads" 25 0 0]
      (try
         ([@GP_Sloc:stack.adb:67:16] [#"stack.adb" 67 0 0] ());
         ([@GP_Sloc:stack.adb:67:7]
          [#"stack.adb" 67 0 0]
          (if (([#"stack.adb" 67 0 0]
                [#"stack.adb" 67 0 0]
                (([@branch_id=1087] Main.spark__branch).bool__content <-
                   (Locker__is_locked___axiom.is_locked Stack__pop2__l.l)));
               (([@branch_id=1087] Main.spark__branch).bool__content)) then
             (([@GP_Sloc:stack.adb:68:17]
               [#"stack.adb" 68 0 0]
               [#"stack.adb" 68 0 0]
               (Stack__pop2__success.success.bool__content <-
                  (Boolean.of_int (0 : int))));
              ([@GP_Sloc:stack.adb:69:11]
               [#"stack.adb" 69 0 0]
               [#"stack.adb" 69 0 0]
               (Stack__pop2__a.a.int__content <- (0 : int)));
              ([@GP_Sloc:stack.adb:70:11]
               [#"stack.adb" 70 0 0]
               [#"stack.adb" 70 0 0]
               (Stack__pop2__b.b.int__content <- (0 : int)));
              ([@GP_Sloc:stack.adb:71:10]
               [#"stack.adb" 71 0 0]
               [#"stack.adb" 71 0 0] ((raise Return__exc) : unit)))
           else ()));
         ([@GP_Sloc:stack.adb:74:7]
          [#"stack.adb" 74 0 0]
          (if (([#"stack.adb" 74 0 0]
                [#"stack.adb" 74 0 0]
                (([@branch_id=1103] Main.spark__branch).bool__content <-
                   (((Standard__natural__rep.to_rep
                        ((Stack__stack_instance.__split_fields
                             { Stack__stack_instance.__split_fields =
                                 (Stack__stack_instance.__split_fields__content
                                     Stack__pop2__s.s__split_fields) }).
                           Stack__stack_instance.rec__stack__stack_instance__top_index))
                       - (2 : int))
                      >= (0 : int))));
               (([@branch_id=1103] Main.spark__branch).bool__content)) then
             (([@GP_Sloc:stack.adb:75:12]
               [#"stack.adb" 75 0 0]
               [#"stack.adb" 75 0 0]
               (Stack__pop2__b.b.int__content <-
                  (Stack__int32__rep.to_rep
                     (let temp___306 =
                        (Stack__stack_instance.__split_fields
                            { Stack__stack_instance.__split_fields =
                                (Stack__stack_instance.__split_fields__content
                                    Stack__pop2__s.s__split_fields) }).
                          Stack__stack_instance.rec__stack__stack_instance__data in
                      (Array__Int__Stack__int32.get temp___306)
                        (let temp___307 =
                           Standard__natural__rep.to_rep
                             ((Stack__stack_instance.__split_fields
                                  { Stack__stack_instance.__split_fields =
                                      (Stack__stack_instance.__split_fields__content
                                          Stack__pop2__s.s__split_fields) }).
                                Stack__stack_instance.rec__stack__stack_instance__top_index) in
                         ([#"stack.adb" 75 0 0]
                          assert {
                            [#"stack.adb" 75 0 0]
                            [#"stack.adb" 75 0 0]
                            [@GP_Id:10]
                            [@GP_Shape:if__b_assign__ixdcomp__selectcomp]
                            [@vc:annotation]
                            [@GP_Sloc:stack.adb:75:23]
                            [@comment:         B := S.Data(S.Top_Index);                       ^ stack.adb:75:23:VC_INDEX_CHECK]
                            [@GP_Reason:VC_INDEX_CHECK]
                            ((Stack__stack_index.first <= temp___307) /\
                               (temp___307 <= Stack__stack_index.last)) });
                         temp___307)))));
              ([@GP_Sloc:stack.adb:76:22]
               [#"stack.adb" 76 0 0]
               (let temp___310 =
                  let temp___309 =
                    { Stack__stack_instance.__split_fields =
                        (Stack__stack_instance.__split_fields__content
                            Stack__pop2__s.s__split_fields) } in
                  ([#"stack.adb" 76 0 0]
                   (begin
                      ensures { true }
                      let _ =
                        let _ =
                          (Stack__stack_instance.__split_fields temp___309).
                            Stack__stack_instance.rec__stack__stack_instance__top_index in
                        () in
                      ()
                    end));
                  ({ temp___309 with
                     Stack__stack_instance.__split_fields =
                       ({ (Stack__stack_instance.__split_fields temp___309) with
                          Stack__stack_instance.rec__stack__stack_instance__top_index =
                            (Standard__natural__rep.of_rep
                               ([#"stack.adb" 76 0 0]
                                [@GP_Id:11]
                                [@GP_Shape:if__s_assign__sub]
                                [@vc:annotation]
                                [@GP_Sloc:stack.adb:76:37]
                                [@GP_Reason:VC_RANGE_CHECK]
                                [@comment:         S.Top_Index := S.Top_Index - 1;                                     ^ stack.adb:76:37:VC_RANGE_CHECK]
                                (Standard__natural.range_check_
                                   ((Standard__natural__rep.to_rep
                                       ((Stack__stack_instance.__split_fields
                                            { Stack__stack_instance.__split_fields =
                                                (Stack__stack_instance.__split_fields__content
                                                    Stack__pop2__s.s__split_fields) }).
                                          Stack__stack_instance.rec__stack__stack_instance__top_index))
                                      - (1 : int))))) }) }) in
                Stack__pop2__s.s__split_fields.Stack__stack_instance.__split_fields__content <-
                  (Stack__stack_instance.__split_fields temp___310)));
              ([@GP_Sloc:stack.adb:77:12]
               [#"stack.adb" 77 0 0]
               [#"stack.adb" 77 0 0]
               (Stack__pop2__a.a.int__content <-
                  (Stack__int32__rep.to_rep
                     (let temp___312 =
                        (Stack__stack_instance.__split_fields
                            { Stack__stack_instance.__split_fields =
                                (Stack__stack_instance.__split_fields__content
                                    Stack__pop2__s.s__split_fields) }).
                          Stack__stack_instance.rec__stack__stack_instance__data in
                      (Array__Int__Stack__int32.get temp___312)
                        (let temp___313 =
                           Standard__natural__rep.to_rep
                             ((Stack__stack_instance.__split_fields
                                  { Stack__stack_instance.__split_fields =
                                      (Stack__stack_instance.__split_fields__content
                                          Stack__pop2__s.s__split_fields) }).
                                Stack__stack_instance.rec__stack__stack_instance__top_index) in
                         ([#"stack.adb" 77 0 0]
                          assert {
                            [#"stack.adb" 77 0 0]
                            [#"stack.adb" 77 0 0]
                            [@GP_Id:12]
                            [@GP_Sloc:stack.adb:77:23]
                            [@comment:         A := S.Data(S.Top_Index);                       ^ stack.adb:77:23:VC_INDEX_CHECK]
                            [@GP_Shape:if__a_assign__ixdcomp__selectcomp]
                            [@vc:annotation]
                            [@GP_Reason:VC_INDEX_CHECK]
                            ((Stack__stack_index.first <= temp___313) /\
                               (temp___313 <= Stack__stack_index.last)) });
                         temp___313)))));
              ([@GP_Sloc:stack.adb:78:22]
               [#"stack.adb" 78 0 0]
               (let temp___316 =
                  let temp___315 =
                    { Stack__stack_instance.__split_fields =
                        (Stack__stack_instance.__split_fields__content
                            Stack__pop2__s.s__split_fields) } in
                  ([#"stack.adb" 78 0 0]
                   (begin
                      ensures { true }
                      let _ =
                        let _ =
                          (Stack__stack_instance.__split_fields temp___315).
                            Stack__stack_instance.rec__stack__stack_instance__top_index in
                        () in
                      ()
                    end));
                  ({ temp___315 with
                     Stack__stack_instance.__split_fields =
                       ({ (Stack__stack_instance.__split_fields temp___315) with
                          Stack__stack_instance.rec__stack__stack_instance__top_index =
                            (Standard__natural__rep.of_rep
                               ([#"stack.adb" 78 0 0]
                                [@GP_Shape:if__s_assign__sub]
                                [@GP_Id:13]
                                [@GP_Sloc:stack.adb:78:37]
                                [@vc:annotation]
                                [@GP_Reason:VC_RANGE_CHECK]
                                [@comment:         S.Top_Index := S.Top_Index - 1;                                     ^ stack.adb:78:37:VC_RANGE_CHECK]
                                (Standard__natural.range_check_
                                   ((Standard__natural__rep.to_rep
                                       ((Stack__stack_instance.__split_fields
                                            { Stack__stack_instance.__split_fields =
                                                (Stack__stack_instance.__split_fields__content
                                                    Stack__pop2__s.s__split_fields) }).
                                          Stack__stack_instance.rec__stack__stack_instance__top_index))
                                      - (1 : int))))) }) }) in
                Stack__pop2__s.s__split_fields.Stack__stack_instance.__split_fields__content <-
                  (Stack__stack_instance.__split_fields temp___316)));
              ([@GP_Sloc:stack.adb:79:18]
               [#"stack.adb" 79 0 0]
               [#"stack.adb" 79 0 0]
               (Stack__pop2__success.success.bool__content <-
                  (Boolean.of_int (1 : int)))))
           else
             ([@GP_Sloc:stack.adb:81:18]
              [#"stack.adb" 81 0 0]
              [#"stack.adb" 81 0 0]
              (Stack__pop2__success.success.bool__content <-
                 (Boolean.of_int (0 : int))))));
         (raise Return__exc)
       with Return__exc -> ()
       end)))
end
