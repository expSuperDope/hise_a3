module Pin__pin
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type pin = <range 0 9999>
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (9999 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = pin,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type pin__ref = { mutable pin__content : pin }
  
  function pin__ref_pin__content__projection (a: pin__ref) : pin =
    a.pin__content
  
  meta "model_projection" function pin__ref_pin__content__projection
  
  meta "inline:no" function pin__ref_pin__content__projection
  
  val pin__havoc (x: pin__ref) : unit
    writes { x }
end

module Pin__pin__rep
  use Pin__pin as Pin__pin
  use _gnatprove_standard.Main
  use int.Int
  
  function to_rep (x: Pin__pin.pin) : int = Pin__pin.pin'int x
  
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Pin__pin.pin,
    predicate in_range = Pin__pin.in_range,
    function to_rep = to_rep
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Locker__locker__rep
  use _gnatprove_standard.Main
  use int.Int
  use _gnatprove_standard.Boolean as Boolean
  use Pin__pin as Pin__pin
  use Pin__pin__rep as Pin__pin__rep
  
  type __split_fields = {
                       rec__locker__locker__number : Pin__pin.pin;
                       rec__locker__locker__locked : bool
                       }
  
  function __split_fields_rec__locker__locker__number__projection (a: __split_fields) : 
    Pin__pin.pin =
    a.rec__locker__locker__number
  
  meta "model_projection" function __split_fields_rec__locker__locker__number__projection
  
  meta "inline:no" function __split_fields_rec__locker__locker__number__projection
  
  function __split_fields_rec__locker__locker__locked__projection (a: __split_fields) : bool =
    a.rec__locker__locker__locked
  
  meta "model_projection" function __split_fields_rec__locker__locker__locked__projection
  
  meta "inline:no" function __split_fields_rec__locker__locker__locked__projection
  
  type __split_fields__ref = {
                            mutable __split_fields__content : __split_fields
                            }
  
  function __split_fields__ref___split_fields__content__2__projection (a: __split_fields__ref) : __split_fields =
    __split_fields__content a
  
  meta "model_projection" function __split_fields__ref___split_fields__content__2__projection
  
  meta "inline:no" function __split_fields__ref___split_fields__content__2__projection
  
  val __split_fields__havoc (x: __split_fields__ref) : unit
    writes { x }
  
  type __rep = { __split_fields : __split_fields }
  
  function __rep___split_fields__2__projection (a: __rep) : __split_fields =
    __split_fields a
  
  meta "model_projection" function __rep___split_fields__2__projection
  
  meta "inline:no" function __rep___split_fields__2__projection
  
  function to_base (a: __rep) : __rep = a
  
  val to_base (a: __rep) : __rep
    ensures { result = (to_base (a : __rep)) }
  
  function of_base (a: __rep) : __rep = a
  
  val of_base (a: __rep) : __rep
    ensures { result = (of_base (a : __rep)) }
  
  predicate locker__locker__number__pred (a: __rep) = true
  
  val locker__locker__number__pred (a: __rep) : bool
    ensures { result <-> (locker__locker__number__pred (a : __rep)) }
  
  val rec__locker__locker__number_ (a: __rep) : Pin__pin.pin
    requires { locker__locker__number__pred a }
    ensures { (result = ((__split_fields a).rec__locker__locker__number)) }
  
  predicate locker__locker__locked__pred (a: __rep) = true
  
  val locker__locker__locked__pred (a: __rep) : bool
    ensures { result <-> (locker__locker__locked__pred (a : __rep)) }
  
  val rec__locker__locker__locked_ (a: __rep) : bool
    requires { locker__locker__locked__pred a }
    ensures { (result = ((__split_fields a).rec__locker__locker__locked)) }
  
  function bool_eq (a: __rep) (b: __rep) : bool =
    if (((Pin__pin__rep.to_rep
            ((__split_fields a).rec__locker__locker__number))
           = (Pin__pin__rep.to_rep
                ((__split_fields b).rec__locker__locker__number))) /\
          ((Boolean.to_int ((__split_fields a).rec__locker__locker__locked))
             = (Boolean.to_int
                  ((__split_fields b).rec__locker__locker__locked)))) then
      True
    else False
  
  val bool_eq (a: __rep) (b: __rep) : bool
    ensures { result = ((bool_eq (a : __rep)) (b : __rep)) }
end

module Locker__locker
  use export Locker__locker__rep
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type locker = __rep
  
  val function value__size : int
  
  val function object__size : int
  
  val function alignment : int
  
  axiom value__size_axiom: (value__size >= (0 : int))
  
  axiom object__size_axiom: (object__size >= (0 : int))
  
  axiom alignment_axiom: (alignment >= (0 : int))
  
  val function locker__locker__number__first__bit : int
  
  val function locker__locker__number__last__bit : int
  
  val function locker__locker__number__position : int
  
  axiom locker__locker__number__first__bit_axiom:
    (locker__locker__number__first__bit >= (0 : int))
  
  axiom locker__locker__number__last__bit_axiom:
    (locker__locker__number__last__bit > locker__locker__number__first__bit)
  
  axiom locker__locker__number__position_axiom:
    (locker__locker__number__position >= (0 : int))
  
  val function locker__locker__locked__first__bit : int
  
  val function locker__locker__locked__last__bit : int
  
  val function locker__locker__locked__position : int
  
  axiom locker__locker__locked__first__bit_axiom:
    (locker__locker__locked__first__bit >= (0 : int))
  
  axiom locker__locker__locked__last__bit_axiom:
    (locker__locker__locked__last__bit > locker__locker__locked__first__bit)
  
  axiom locker__locker__locked__position_axiom:
    (locker__locker__locked__position >= (0 : int))
  
  val function user_eq (a: locker) (b: locker) : bool
  
  val function dummy : locker
  
  type locker__ref = { mutable locker__content : locker }
  
  function locker__ref_locker__content__projection (a: locker__ref) : locker =
    a.locker__content
  
  meta "model_projection" function locker__ref_locker__content__projection
  
  meta "inline:no" function locker__ref_locker__content__projection
  
  val locker__havoc (x: locker__ref) : unit
    writes { x }
end

module Calculator__int32
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type int32 = <range -2147483648 2147483647>
  
  val function first : int
    ensures { result = ((- 2147483648) : int) }
  
  val function last : int
    ensures { result = (2147483647 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = int32,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type int32__ref = { mutable int32__content : int32 }
  
  function int32__ref_int32__content__projection (a: int32__ref) : int32 =
    a.int32__content
  
  meta "model_projection" function int32__ref_int32__content__projection
  
  meta "inline:no" function int32__ref_int32__content__projection
  
  val int32__havoc (x: int32__ref) : unit
    writes { x }
end

module Calculator__int32__rep
  use Calculator__int32 as Calculator__int32
  use _gnatprove_standard.Main
  use int.Int
  
  function to_rep (x: Calculator__int32.int32) : int =
    Calculator__int32.int32'int x
  
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Calculator__int32.int32,
    predicate in_range = Calculator__int32.in_range,
    function to_rep = to_rep
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Calculator__result__rep
  use _gnatprove_standard.Main
  use int.Int
  use _gnatprove_standard.Boolean as Boolean
  use Calculator__int32 as Calculator__int32
  use Calculator__int32__rep as Calculator__int32__rep
  
  type __split_fields = {
                       rec__calculator__result__success : bool;
                       rec__calculator__result__value :
                         Calculator__int32.int32
                       }
  
  function __split_fields_rec__calculator__result__success__projection (a: __split_fields) : bool =
    a.rec__calculator__result__success
  
  meta "model_projection" function __split_fields_rec__calculator__result__success__projection
  
  meta "inline:no" function __split_fields_rec__calculator__result__success__projection
  
  function __split_fields_rec__calculator__result__value__projection (a: __split_fields) : 
    Calculator__int32.int32 =
    a.rec__calculator__result__value
  
  meta "model_projection" function __split_fields_rec__calculator__result__value__projection
  
  meta "inline:no" function __split_fields_rec__calculator__result__value__projection
  
  type __split_fields__ref = {
                            mutable __split_fields__content : __split_fields
                            }
  
  function __split_fields__ref___split_fields__content__projection (a: __split_fields__ref) : __split_fields =
    __split_fields__content a
  
  meta "model_projection" function __split_fields__ref___split_fields__content__projection
  
  meta "inline:no" function __split_fields__ref___split_fields__content__projection
  
  val __split_fields__havoc (x: __split_fields__ref) : unit
    writes { x }
  
  type __rep = { __split_fields : __split_fields }
  
  function __rep___split_fields__projection (a: __rep) : __split_fields =
    __split_fields a
  
  meta "model_projection" function __rep___split_fields__projection
  
  meta "inline:no" function __rep___split_fields__projection
  
  function to_base (a: __rep) : __rep = a
  
  val to_base (a: __rep) : __rep
    ensures { result = (to_base (a : __rep)) }
  
  function of_base (a: __rep) : __rep = a
  
  val of_base (a: __rep) : __rep
    ensures { result = (of_base (a : __rep)) }
  
  predicate calculator__result__success__pred (a: __rep) = true
  
  val calculator__result__success__pred (a: __rep) : bool
    ensures { result <-> (calculator__result__success__pred (a : __rep)) }
  
  val rec__calculator__result__success_ (a: __rep) : bool
    requires { calculator__result__success__pred a }
    ensures { (result
                 = ((__split_fields a).rec__calculator__result__success)) }
  
  predicate calculator__result__value__pred (a: __rep) = true
  
  val calculator__result__value__pred (a: __rep) : bool
    ensures { result <-> (calculator__result__value__pred (a : __rep)) }
  
  val rec__calculator__result__value_ (a: __rep) : Calculator__int32.int32
    requires { calculator__result__value__pred a }
    ensures { (result = ((__split_fields a).rec__calculator__result__value)) }
  
  function bool_eq (a: __rep) (b: __rep) : bool =
    if (((Boolean.to_int
            ((__split_fields a).rec__calculator__result__success))
           = (Boolean.to_int
                ((__split_fields b).rec__calculator__result__success))) /\
          ((Calculator__int32__rep.to_rep
              ((__split_fields a).rec__calculator__result__value))
             = (Calculator__int32__rep.to_rep
                  ((__split_fields b).rec__calculator__result__value)))) then
      True
    else False
  
  val bool_eq (a: __rep) (b: __rep) : bool
    ensures { result = ((bool_eq (a : __rep)) (b : __rep)) }
end

module Calculator__result
  use export Calculator__result__rep
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type result__ = __rep
  
  val function value__size : int
  
  val function object__size : int
  
  val function alignment : int
  
  axiom value__size_axiom: (value__size >= (0 : int))
  
  axiom object__size_axiom: (object__size >= (0 : int))
  
  axiom alignment_axiom: (alignment >= (0 : int))
  
  val function calculator__result__success__first__bit : int
  
  val function calculator__result__success__last__bit : int
  
  val function calculator__result__success__position : int
  
  axiom calculator__result__success__first__bit_axiom:
    (calculator__result__success__first__bit >= (0 : int))
  
  axiom calculator__result__success__last__bit_axiom:
    (calculator__result__success__last__bit
       > calculator__result__success__first__bit)
  
  axiom calculator__result__success__position_axiom:
    (calculator__result__success__position >= (0 : int))
  
  val function calculator__result__value__first__bit : int
  
  val function calculator__result__value__last__bit : int
  
  val function calculator__result__value__position : int
  
  axiom calculator__result__value__first__bit_axiom:
    (calculator__result__value__first__bit >= (0 : int))
  
  axiom calculator__result__value__last__bit_axiom:
    (calculator__result__value__last__bit
       > calculator__result__value__first__bit)
  
  axiom calculator__result__value__position_axiom:
    (calculator__result__value__position >= (0 : int))
  
  val function user_eq (a: result__) (b: result__) : bool
  
  val function dummy : result__
  
  type result____ref = { mutable result____content : result__ }
  
  function result____ref_result____content__projection (a: result____ref) : result__ =
    a.result____content
  
  meta "model_projection" function result____ref_result____content__projection
  
  meta "inline:no" function result____ref_result____content__projection
  
  val result____havoc (x: result____ref) : unit
    writes { x }
end

module Calculator__mul__l
  use _gnatprove_standard.Main
  use int.Int
  use Locker__locker as Locker__locker
  
  val function l : Locker__locker.locker
end

module Calculator__mul__a
  use _gnatprove_standard.Main
  use int.Int
  
  val function a : int
end

module Calculator__mul__b
  use _gnatprove_standard.Main
  use int.Int
  
  val function b : int
end

module Locker__is_locked
  use _gnatprove_standard.Main
  use int.Int
  use Locker__locker as Locker__locker
  
  val function is_locked (l: Locker__locker.locker) : bool
  
  val predicate is_locked__function_guard (temp___result_167: bool) (l: 
    Locker__locker.locker)
end

module Locker__locker___axiom
  use _gnatprove_standard.Main
  use int.Int
  use Locker__locker as Locker__locker
  
  predicate dynamic_invariant (temp___expr_223: Locker__locker.locker) (temp___is_init_219: bool) (temp___skip_constant_220: bool) (temp___do_toplevel_221: bool) (temp___do_typ_inv_222: bool) =
    true
  
  val dynamic_invariant (temp___expr_223: Locker__locker.locker) (temp___is_init_219: bool) (temp___skip_constant_220: bool) (temp___do_toplevel_221: bool) (temp___do_typ_inv_222: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant
                       (temp___expr_223 : Locker__locker.locker))
                      (temp___is_init_219 : bool))
                     (temp___skip_constant_220 : bool))
                    (temp___do_toplevel_221 : bool))
                   (temp___do_typ_inv_222 : bool)) }
  
  predicate default_initial_assumption (temp___expr_224: Locker__locker.locker) (temp___skip_top_level_225: bool) =
    true
  
  val default_initial_assumption (temp___expr_224: Locker__locker.locker) (temp___skip_top_level_225: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption
                    (temp___expr_224 : Locker__locker.locker))
                   (temp___skip_top_level_225 : bool)) }
end

module Locker__is_locked___axiom
  use _gnatprove_standard.Main
  use int.Int
  use Locker__locker as Locker__locker
  use Locker__is_locked as Locker__is_locked
  use Locker__locker___axiom as Locker__locker___axiom
  
  val is_locked (l: Locker__locker.locker) : bool
    requires { true }
    ensures { (((result = (Locker__is_locked.is_locked l)) /\
                  ((Locker__is_locked.is_locked__function_guard result) l)) /\
                 true) }
  
  axiom is_locked__post_axiom:
    forall l : Locker__locker.locker [Locker__is_locked.is_locked l].
      ((((((Locker__locker___axiom.dynamic_invariant l) True) True) True)
          True) ->
         (let result = Locker__is_locked.is_locked l in
          if ((Locker__is_locked.is_locked__function_guard result) l) then
            ((true /\ true) /\ true)
          else true))
end

module Calculator__mul__v
  use _gnatprove_standard.Main
  use int.Int
  
  val v : int__ref
end

module Calculator__int32___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Calculator__int32 as Calculator__int32
  
  predicate dynamic_invariant (temp___expr_186: int) (temp___is_init_182: bool) (temp___skip_constant_183: bool) (temp___do_toplevel_184: bool) (temp___do_typ_inv_185: bool) =
    if ((temp___is_init_182 = True) \/
          (Calculator__int32.first <= Calculator__int32.last)) then
      (((Calculator__int32.dynamic_property Calculator__int32.first)
          Calculator__int32.last)
         temp___expr_186)
    else true
  
  val dynamic_invariant (temp___expr_186: int) (temp___is_init_182: bool) (temp___skip_constant_183: bool) (temp___do_toplevel_184: bool) (temp___do_typ_inv_185: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_186 : int))
                      (temp___is_init_182 : bool))
                     (temp___skip_constant_183 : bool))
                    (temp___do_toplevel_184 : bool))
                   (temp___do_typ_inv_185 : bool)) }
  
  predicate default_initial_assumption (temp___expr_187: int) (temp___skip_top_level_188: bool) =
    true
  
  val default_initial_assumption (temp___expr_187: int) (temp___skip_top_level_188: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_187 : int))
                   (temp___skip_top_level_188 : bool)) }
end

module Calculator__int64
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type int64 = <range -9223372036854775808 9223372036854775807>
  
  val function first : int
    ensures { result = ((- 9223372036854775808) : int) }
  
  val function last : int
    ensures { result = (9223372036854775807 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = int64,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type int64__ref = { mutable int64__content : int64 }
  
  function int64__ref_int64__content__projection (a: int64__ref) : int64 =
    a.int64__content
  
  meta "model_projection" function int64__ref_int64__content__projection
  
  meta "inline:no" function int64__ref_int64__content__projection
  
  val int64__havoc (x: int64__ref) : unit
    writes { x }
end

module Calculator__int64___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Calculator__int64 as Calculator__int64
  
  predicate dynamic_invariant (temp___expr_200: int) (temp___is_init_196: bool) (temp___skip_constant_197: bool) (temp___do_toplevel_198: bool) (temp___do_typ_inv_199: bool) =
    if ((temp___is_init_196 = True) \/
          (Calculator__int64.first <= Calculator__int64.last)) then
      (((Calculator__int64.dynamic_property Calculator__int64.first)
          Calculator__int64.last)
         temp___expr_200)
    else true
  
  val dynamic_invariant (temp___expr_200: int) (temp___is_init_196: bool) (temp___skip_constant_197: bool) (temp___do_toplevel_198: bool) (temp___do_typ_inv_199: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_200 : int))
                      (temp___is_init_196 : bool))
                     (temp___skip_constant_197 : bool))
                    (temp___do_toplevel_198 : bool))
                   (temp___do_typ_inv_199 : bool)) }
  
  predicate default_initial_assumption (temp___expr_201: int) (temp___skip_top_level_202: bool) =
    true
  
  val default_initial_assumption (temp___expr_201: int) (temp___skip_top_level_202: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_201 : int))
                   (temp___skip_top_level_202 : bool)) }
end

module Calculator__mul__v___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Calculator__result___axiom
  use _gnatprove_standard.Main
  use int.Int
  use Calculator__result as Calculator__result
  
  predicate dynamic_invariant (temp___expr_207: Calculator__result.result__) (temp___is_init_203: bool) (temp___skip_constant_204: bool) (temp___do_toplevel_205: bool) (temp___do_typ_inv_206: bool) =
    true
  
  val dynamic_invariant (temp___expr_207: Calculator__result.result__) (temp___is_init_203: bool) (temp___skip_constant_204: bool) (temp___do_toplevel_205: bool) (temp___do_typ_inv_206: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant
                       (temp___expr_207 : Calculator__result.result__))
                      (temp___is_init_203 : bool))
                     (temp___skip_constant_204 : bool))
                    (temp___do_toplevel_205 : bool))
                   (temp___do_typ_inv_206 : bool)) }
  
  predicate default_initial_assumption (temp___expr_208: Calculator__result.result__) (temp___skip_top_level_209: bool) =
    true
  
  val default_initial_assumption (temp___expr_208: Calculator__result.result__) (temp___skip_top_level_209: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption
                    (temp___expr_208 : Calculator__result.result__))
                   (temp___skip_top_level_209 : bool)) }
end

module Calculator__mul__l___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Calculator__mul__a___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Calculator__mul__b___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Pin__pin___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Pin__pin as Pin__pin
  
  predicate dynamic_invariant (temp___expr_216: int) (temp___is_init_212: bool) (temp___skip_constant_213: bool) (temp___do_toplevel_214: bool) (temp___do_typ_inv_215: bool) =
    if ((temp___is_init_212 = True) \/ (Pin__pin.first <= Pin__pin.last)) then
      (((Pin__pin.dynamic_property Pin__pin.first) Pin__pin.last)
         temp___expr_216)
    else true
  
  val dynamic_invariant (temp___expr_216: int) (temp___is_init_212: bool) (temp___skip_constant_213: bool) (temp___do_toplevel_214: bool) (temp___do_typ_inv_215: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_216 : int))
                      (temp___is_init_212 : bool))
                     (temp___skip_constant_213 : bool))
                    (temp___do_toplevel_214 : bool))
                   (temp___do_typ_inv_215 : bool)) }
  
  predicate default_initial_assumption (temp___expr_217: int) (temp___skip_top_level_218: bool) =
    true
  
  val default_initial_assumption (temp___expr_217: int) (temp___skip_top_level_218: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_217 : int))
                   (temp___skip_top_level_218 : bool)) }
end

module Calculator__mul__subprogram_def
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use _gnatprove_standard.Main as Main
  use _gnatprove_standard.Boolean as Boolean
  use Locker__locker as Locker__locker
  use Calculator__result as Calculator__result
  use Calculator__mul__l as Calculator__mul__l
  use Calculator__mul__a as Calculator__mul__a
  use Calculator__mul__b as Calculator__mul__b
  use Locker__is_locked___axiom as Locker__is_locked___axiom
  use Calculator__mul__v as Calculator__mul__v
  use Calculator__int32 as Calculator__int32
  use Calculator__int32___axiom as Calculator__int32___axiom
  use Calculator__int32__rep as Calculator__int32__rep
  use Calculator__int64___axiom as Calculator__int64___axiom
  use Locker__locker___axiom as Locker__locker___axiom
  use Calculator__mul__v___axiom as Calculator__mul__v___axiom
  use Calculator__int32___axiom as Calculator__int32___axiom
  use Calculator__int64___axiom as Calculator__int64___axiom
  use Calculator__result___axiom as Calculator__result___axiom
  use Calculator__mul__l___axiom as Calculator__mul__l___axiom
  use Calculator__mul__a___axiom as Calculator__mul__a___axiom
  use Calculator__mul__b___axiom as Calculator__mul__b___axiom
  use Locker__is_locked___axiom as Locker__is_locked___axiom
  use Locker__locker___axiom as Locker__locker___axiom
  use Pin__pin___axiom as Pin__pin___axiom
  
  val calculator__mul__result : Calculator__result.result____ref
  
  let def (__void_param : unit)
    requires { [#"calculator.ads" 18 0 0] true }
  = [@vc:divergent]
    (([@GNAT-comment:Assume dynamic invariants of inputs of the subprogram calculator.ads:18]
      ());
     ([#"calculator.ads" 18 0 0]
      assume {
        [#"calculator.ads" 18 0 0]
        (((((Locker__locker___axiom.dynamic_invariant Calculator__mul__l.l)
              True)
             False)
            True)
           True) });
     ([#"calculator.ads" 18 0 0]
      assume {
        [#"calculator.ads" 18 0 0]
        (((((Calculator__int32___axiom.dynamic_invariant Calculator__mul__a.a)
              True)
             False)
            True)
           True) });
     ([#"calculator.ads" 18 0 0]
      assume {
        [#"calculator.ads" 18 0 0]
        (((((Calculator__int32___axiom.dynamic_invariant Calculator__mul__b.b)
              True)
             False)
            True)
           True) });
     ([@GNAT-comment:Assume moved pointers in outputs of the subprogram calculator.ads:18]
      ());
     ([@GNAT-comment:Check for RTE in the Pre of the subprogram calculator.ads:18]
      ());
     ([#"calculator.ads" 18 0 0] ());
     ([@GNAT-comment:Assume Pre of the subprogram calculator.ads:18] ());
     ([#"calculator.ads" 18 0 0]
      (try
         ([#"calculator.adb" 37 0 0]
          (([#"calculator.adb" 37 0 0]
            (Calculator__mul__v.v.int__content <-
               (Calculator__mul__a.a * Calculator__mul__b.b)));
           ([#"calculator.adb" 37 0 0]
            assume {
              [#"calculator.adb" 37 0 0]
              (((((Calculator__int64___axiom.dynamic_invariant
                     (Calculator__mul__v.v.int__content))
                    True)
                   False)
                  True)
                 True) })));
         ([@GP_Sloc:calculator.adb:39:16] [#"calculator.adb" 39 0 0] ());
         ([@GP_Sloc:calculator.adb:39:7]
          [#"calculator.adb" 39 0 0]
          (if (([#"calculator.adb" 39 0 0]
                [#"calculator.adb" 39 0 0]
                (([@branch_id=1002] Main.spark__branch).bool__content <-
                   (Locker__is_locked___axiom.is_locked Calculator__mul__l.l)));
               (([@branch_id=1002] Main.spark__branch).bool__content)) then
             ([@GP_Sloc:calculator.adb:40:10]
              [#"calculator.adb" 40 0 0]
              (([#"calculator.adb" 40 0 0]
                (calculator__mul__result.Calculator__result.result____content <-
                   { Calculator__result.__split_fields =
                       { Calculator__result.rec__calculator__result__success =
                           (Boolean.of_int (0 : int)) ;
                         Calculator__result.rec__calculator__result__value =
                           (0 : Calculator__int32.int32) } }));
               ([#"calculator.adb" 40 0 0] ((raise Return__exc) : unit))))
           else ()));
         ([@GP_Sloc:calculator.adb:43:10] [#"calculator.adb" 43 0 0] ());
         ([@GP_Sloc:calculator.adb:43:7]
          [#"calculator.adb" 43 0 0]
          (if (([#"calculator.adb" 43 0 0]
                [#"calculator.adb" 43 0 0]
                (([@branch_id=1016] Main.spark__branch).bool__content <-
                   (((Calculator__mul__v.v.int__content)
                       < ((- 2147483648) : int))
                     ||
                      ((Calculator__mul__v.v.int__content)
                         > (2147483647 : int)))));
               (([@branch_id=1016] Main.spark__branch).bool__content)) then
             ([@GP_Sloc:calculator.adb:44:10]
              [#"calculator.adb" 44 0 0]
              (([#"calculator.adb" 44 0 0]
                (calculator__mul__result.Calculator__result.result____content <-
                   { Calculator__result.__split_fields =
                       { Calculator__result.rec__calculator__result__success =
                           (Boolean.of_int (0 : int)) ;
                         Calculator__result.rec__calculator__result__value =
                           (0 : Calculator__int32.int32) } }));
               ([#"calculator.adb" 44 0 0] ((raise Return__exc) : unit))))
           else
             (([@GP_Sloc:calculator.adb:46:46] [#"calculator.adb" 46 0 0] ());
              ([@GP_Sloc:calculator.adb:46:10]
               [#"calculator.adb" 46 0 0]
               (([#"calculator.adb" 46 0 0]
                 (calculator__mul__result.Calculator__result.result____content <-
                    { Calculator__result.__split_fields =
                        { Calculator__result.rec__calculator__result__success =
                            (Boolean.of_int (1 : int)) ;
                          Calculator__result.rec__calculator__result__value =
                            (Calculator__int32__rep.of_rep
                               ([#"calculator.adb" 46 0 0]
                                [@GP_Sloc:calculator.adb:46:46]
                                [@vc:annotation]
                                [@GP_Reason:VC_RANGE_CHECK]
                                [@GP_Shape:if__return__aggr__typeconv]
                                [@comment:         return (Success=>True, Value=>Int32(V));                                              ^ calculator.adb:46:46:VC_RANGE_CHECK]
                                [@GP_Id:2]
                                (Calculator__int32.range_check_
                                   (Calculator__mul__v.v.int__content)))) } }));
                ((raise Return__exc) : unit))))));
         (raise Return__exc)
       with Return__exc -> ()
       end));
     (calculator__mul__result.Calculator__result.result____content))
end
